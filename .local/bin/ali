#!/bin/bash
##############################################################################
## ali - List aliases and their origin (FIXED VERSION)
## Prerequisites: ~/local/bin is included in your $PATH
##
## List all aliases and their source files in a nicely formatted table.
## Improvements: Security hardening, portability, performance optimization
##############################################################################

# Strict mode
set -o pipefail

# Validate environment
: "${SHELL:?SHELL environment variable not set}"
: "${HOME:?HOME environment variable not set}"

# Define colors for improved readability
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m'  # No color

# Configuration constants
readonly MAX_CMD_LENGTH=50
readonly ALIAS_COL_WIDTH=20
readonly COMMAND_COL_WIDTH=60
readonly LOCATION_COL_WIDTH=50
readonly MAX_RECURSION_DEPTH=10

# Global state
TRUNCATED_FLAG=0
DEBUG_MODE=0
declare -a SHELL_CONFIG_CACHE=()

# Debug function - conditionally logs messages
debug() {
    [[ $DEBUG_MODE -eq 1 ]] && echo -e "${YELLOW}DEBUG: $1${NC}" >&2
}

# Escape regex special characters to prevent injection
escape_regex() {
    local str="$1"
    printf '%s\n' "$str" | sed 's/[[\.*^$/]/\\&/g'
}

# Safe parameter expansion (no eval)
safe_expand() {
    local var="$1"
    # Use bash parameter expansion with @P operator (bash 4.4+)
    if [[ "${BASH_VERSINFO[0]}" -ge 4 ]] && [[ "${BASH_VERSINFO[1]}" -ge 4 ]]; then
        printf '%s\n' "${var@P}" 2>/dev/null || printf '%s\n' "$var"
    else
        # Fallback: just return the variable as-is
        printf '%s\n' "$var"
    fi
}

# Detect the active shell type
detect_shell_type() {
    local shell_name
    shell_name=$(basename "$SHELL")
    case "$shell_name" in
        zsh) echo "zsh" ;;
        bash|sh) echo "bash" ;;
        *) echo "bash" ;; # Default to bash
    esac
}

# Recursively find sourced files (with cycle detection)
find_sourced_files() {
    local file="$1"
    local depth="$2"
    
    if [[ $depth -gt 10 ]] || [[ ! -f "$file" ]]; then
        return
    fi

    echo "$file"

    # ONLY match actual source/. commands, nothing else
    grep -E "^[[:space:]]*(source|\.|\.\.)[[:space:]]+" "$file" 2>/dev/null | \
    while IFS= read -r line; do
        # Extract just the filename, nothing fancy
        local sourced_file
        sourced_file=$(echo "$line" | awk '{print $2}')
        sourced_file=$(eval echo "$sourced_file" 2>/dev/null || echo "$sourced_file")
        
        [[ ! "$sourced_file" = /* ]] && sourced_file="$(dirname "$file")/$sourced_file"
        
        if [[ -f "$sourced_file" ]]; then
            find_sourced_files "$sourced_file" $((depth + 1))
        fi
    done
}

# Find all possible shell configuration files
find_shell_config_files() {
    local shell_name
    shell_name=$(detect_shell_type)
    
    local -a all_files=()
    local file

    # Primary config files
    local -a initial_files=(
        "$HOME/.config/${shell_name}/.${shell_name}rc"
        "$HOME/.config/${shell_name}/.zprofile"
        "$HOME/.config/${shell_name}/.bash_profile"
        "$HOME/.${shell_name}rc"
        "$HOME/.profile"
        "/etc/${shell_name}rc"
        "/etc/profile"
    )

    for file in "${initial_files[@]}"; do
        if [[ -f "$file" ]]; then
            all_files+=("$file")
            # Recursively find sourced files
            while IFS= read -r sourced_file; do
                all_files+=("$sourced_file")
            done < <(find_sourced_files "$file" 0)
        fi
    done

    # Also search config directories for .zsh files
    local config_dir="$HOME/.config/${shell_name}"
    if [[ -d "$config_dir" ]]; then
        while IFS= read -r file; do
            all_files+=("$file")
        done < <(find "$config_dir" -type f \( -name "*.zsh" -o -name ".zaliases" -o -name ".bash_aliases" \) 2>/dev/null)
    fi

    # Search ZSH_CUSTOM directory if it exists
    if [[ -d "${ZSH_CUSTOM}" ]]; then
        while IFS= read -r file; do
            all_files+=("$file")
        done < <(find "${ZSH_CUSTOM}" -type f -name "*.zsh" 2>/dev/null)
    fi

    # Remove duplicates and sort
    printf '%s\n' "${all_files[@]}" | sort -u
}

# Cache shell config files (call once, reuse many times)
get_cached_shell_config_files() {
    if [[ ${#SHELL_CONFIG_CACHE[@]} -eq 0 ]]; then
        while IFS= read -r file; do
            SHELL_CONFIG_CACHE+=("$file")
        done < <(find_shell_config_files)
    fi
    printf '%s\n' "${SHELL_CONFIG_CACHE[@]}"
}

# Replace home directory path with ~ for readability
replace_home_with_tilde() {
    local path="$1"
    local home_path
    home_path=$(eval echo "~")
    printf '%s\n' "${path//$home_path/\~}"
}

# Find the source file of a specific alias (uses portable grep)
find_alias_source() {
    local alias_name="$1"
    
    if [[ -z "$alias_name" ]]; then
        echo "Runtime defined or unknown source"
        return 1
    fi

    debug "Searching for alias: $alias_name"

    # Escape regex special characters in alias name
    local escaped_name
    escaped_name=$(escape_regex "$alias_name")

    # Use -E (extended regex) instead of -P for portability
    local file
    while IFS= read -r file; do
        debug "Checking file: $file"
        if grep -qE "^[[:space:]]*(alias[[:space:]]+${escaped_name}=|function[[:space:]]+${escaped_name}[[:space:]]*\()" "$file" 2>/dev/null; then
            debug "Found alias in: $file"
            echo "$file"
            return 0
        fi
    done < <(get_cached_shell_config_files)

    debug "Alias not found in any config file"
    echo "Runtime defined or unknown source"
    return 1
}

# Parse alias output line intelligently (no external pipes)
parse_alias_line() {
    local line="$1"
    local shell_type="$2"
    
    # Extract name and command from "name='command'" format
    local name command
    
    if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
        name="${BASH_REMATCH[1]}"
        command="${BASH_REMATCH[2]}"
        
        # Trim whitespace
        name="${name##*( )}"
        name="${name%%*( )}"
        
        # Remove surrounding quotes
        command="${command#\'}"
        command="${command%\'}"
        command="${command#\"}"
        command="${command%\"}"
    else
        return 1
    fi
    
    printf '%s\n%s\n' "$name" "$command"
}

# Extract aliases from the current shell (without sourcing untrusted files)
extract_active_aliases() {
    local shell_type
    shell_type=$(detect_shell_type)
    
    debug "Extracting aliases for shell: $shell_type"

    # Create temp file
    local temp_file
    temp_file=$(mktemp) || {
        echo "Error: Failed to create temporary file" >&2
        return 1
    }
    
    # Get alias definitions from config files (grep, don't source)
    local file
    while IFS= read -r file; do
        grep -h "^[[:space:]]*alias[[:space:]]" "$file" 2>/dev/null >> "$temp_file"
    done < <(find_shell_config_files)

    debug "Aliases stored in temporary file: $temp_file"

    # Process aliases
    local line name command location
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        
        # Parse the alias line: alias name='command' or alias name="command"
        # Remove leading whitespace and 'alias ' prefix
        line="${line##*alias[[:space:]]}"
        
        # Split on first = only
        if [[ "$line" =~ ^([^=]+)= ]]; then
            name="${BASH_REMATCH[1]}"
            command="${line#*=}"
            
            # Trim whitespace from name
            name="$(echo "$name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            
            # Remove quotes from command
            command="${command#\'}"
            command="${command%\'}"
            command="${command#\"}"
            command="${command%\"}"
        else
            continue
        fi

        [[ -z "$name" ]] && continue

        debug "Processing alias: $name"

        # Truncate if needed
        if (( ${#command} > MAX_CMD_LENGTH )); then
            command="${command:0:$MAX_CMD_LENGTH}...*"
            TRUNCATED_FLAG=1
        fi

        # Find source
        location=$(find_alias_source "$name")
        
        command=$(replace_home_with_tilde "$command")
        location=$(replace_home_with_tilde "$location")

        printf "${GREEN}%-${ALIAS_COL_WIDTH}s${NC} ${YELLOW}%-${COMMAND_COL_WIDTH}s${NC} ${RED}%-${LOCATION_COL_WIDTH}s${NC}\n" \
            "$name" "$command" "$location"
            
    done < "$temp_file"
    
    # Cleanup
    rm -f "$temp_file"
}

# Main function to display aliases
process_aliases() {
    # Print header
    printf "${GREEN}%-${ALIAS_COL_WIDTH}s${NC} ${YELLOW}%-${COMMAND_COL_WIDTH}s${NC} ${RED}%-${LOCATION_COL_WIDTH}s${NC}\n" \
        "Alias" "Command" "Location"
    printf "%-${ALIAS_COL_WIDTH}s %-${COMMAND_COL_WIDTH}s %-${LOCATION_COL_WIDTH}s\n" \
        "-----" "-------" "--------"

    # Extract and display aliases
    extract_active_aliases

    # Print footer note if truncation occurred
    if (( TRUNCATED_FLAG == 1 )); then
        printf "\n${YELLOW}* indicates truncated command. View source file for full command.${NC}\n"
    fi
}

# Parse command-line arguments
main() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--debug)
                DEBUG_MODE=1
                shift
                ;;
            -h|--help)
                cat <<EOF
Usage: ali [OPTIONS]

Options:
  -d, --debug    Enable debug output
  -h, --help     Show this help message

Description:
  List all shell aliases with their source locations.

EOF
                return 0
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                return 1
                ;;
        esac
    done

    process_aliases
}

# Execute main function
main "$@"
