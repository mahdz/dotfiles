#!/usr/bin/env zsh
# Log Rotation Script for Basic Memory
# 
# PURPOSE:
#   Manages log file growth by archiving and compressing old logs
#   Keeps system responsive by preventing large log files from accumulating
# 
# USAGE:
#   ./rotate-logs [--dry-run] [--days N] [--keep N]
#   
#   --dry-run    Show what would be done without making changes
#   --days N     Archive logs older than N days (default: 7)
#   --keep N     Keep N most recent archives (default: 5)
#
# EXAMPLES:
#   ./rotate-logs --dry-run          # Preview actions
#   ./rotate-logs --days 3           # Archive logs older than 3 days
#   ./rotate-logs --days 7 --keep 3  # Archive 7+ day logs, keep 3 archives
#
# AUTOMATION:
#   Add to crontab for automatic rotation:
#   # Rotate logs weekly on Sunday at 2 AM
#   0 2 * * 0 /Users/mh/bin/rotate-logs >/dev/null 2>&1

set -euo pipefail

# Configuration
readonly LOGS_DIR="$HOME/.basic-memory"
readonly ARCHIVE_DIR="$LOGS_DIR/archives"
readonly DEFAULT_DAYS=7
readonly DEFAULT_KEEP=5
readonly SCRIPT_NAME=$(basename "$0")

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Functions
info() { echo -e "${BLUE}[INFO]${NC} $*" >&2; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $*" >&2; }
warn() { echo -e "${YELLOW}[WARN]${NC} $*" >&2; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
dry_run_info() { [[ ${DRY_RUN:-0} -eq 1 ]] && echo -e "${YELLOW}[DRY-RUN]${NC} $*" >&2; }

usage() {
    cat << EOF
$SCRIPT_NAME - Rotate and archive log files

USAGE:
    $SCRIPT_NAME [OPTIONS]

OPTIONS:
    --dry-run       Show what would be done without making changes
    --days N        Archive logs older than N days (default: $DEFAULT_DAYS)
    --keep N        Keep N most recent archives (default: $DEFAULT_KEEP)
    --help         Show this help message

EXAMPLES:
    $SCRIPT_NAME --dry-run
    $SCRIPT_NAME --days 3 --keep 10
EOF
}

# Parse command line arguments
parse_args() {
    DAYS_THRESHOLD=$DEFAULT_DAYS
    KEEP_ARCHIVES=$DEFAULT_KEEP
    DRY_RUN=0
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                DRY_RUN=1
                shift
                ;;
            --days)
                DAYS_THRESHOLD="$2"
                shift 2
                ;;
            --keep)
                KEEP_ARCHIVES="$2"
                shift 2
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Validate numeric arguments
    if ! [[ "$DAYS_THRESHOLD" =~ ^[0-9]+$ ]] || [[ $DAYS_THRESHOLD -lt 1 ]]; then
        error "Days threshold must be a positive integer"
        exit 1
    fi
    
    if ! [[ "$KEEP_ARCHIVES" =~ ^[0-9]+$ ]] || [[ $KEEP_ARCHIVES -lt 1 ]]; then
        error "Keep archives must be a positive integer"
        exit 1
    fi
}

# Check if logs directory exists
check_logs_dir() {
    if [[ ! -d "$LOGS_DIR" ]]; then
        error "Logs directory not found: $LOGS_DIR"
        exit 1
    fi
}

# Create archives directory if it doesn't exist
ensure_archive_dir() {
    if [[ ! -d "$ARCHIVE_DIR" ]]; then
        if [[ $DRY_RUN -eq 1 ]]; then
            dry_run_info "Would create archive directory: $ARCHIVE_DIR"
        else
            info "Creating archive directory: $ARCHIVE_DIR"
            mkdir -p "$ARCHIVE_DIR"
        fi
    fi
}

# Get log files that need rotation
get_logs_to_rotate() {
    local cutoff_timestamp
    cutoff_timestamp=$(date -j -v-${DAYS_THRESHOLD}d '+%s')
    
    find "$LOGS_DIR" -maxdepth 1 -name "*.log" -type f | while IFS= read -r log_file; do
        local file_timestamp
        file_timestamp=$(stat -f '%m' "$log_file")
        
        if [[ "$file_timestamp" -lt "$cutoff_timestamp" ]]; then
            echo "$log_file"
        fi
    done
}

# Archive a single log file
archive_log() {
    local log_file="$1"
    local log_name=$(basename "$log_file" .log)
    local timestamp=$(date '+%Y%m%d_%H%M%S')
    local archive_name="${log_name}_${timestamp}.log.gz"
    local archive_path="$ARCHIVE_DIR/$archive_name"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        dry_run_info "Would compress: $(basename "$log_file") -> $archive_name"
        dry_run_info "Would truncate: $(basename "$log_file")"
    else
        info "Compressing: $(basename "$log_file") -> $archive_name"
        
        # Compress the log file
        gzip -c "$log_file" > "$archive_path"
        
        # Truncate the original log (preserve file for active processes)
        > "$log_file"
        
        success "Archived: $archive_name"
    fi
}

# Clean up old archives
cleanup_old_archives() {
    local archive_pattern="$1"
    local archives_to_remove
    
    # Skip if archive directory doesn't exist
    if [[ ! -d "$ARCHIVE_DIR" ]]; then
        return 0
    fi
    
    # Find archives matching pattern, sort by modification time (newest first),
    # skip the number we want to keep, and get the rest for deletion
    archives_to_remove=$(find "$ARCHIVE_DIR" -name "${archive_pattern}_*.log.gz" -type f -print0 2>/dev/null | \
                        xargs -0 ls -t 2>/dev/null | \
                        tail -n +$((KEEP_ARCHIVES + 1)) 2>/dev/null || true)
    
    if [[ -n "$archives_to_remove" ]]; then
        while IFS= read -r archive; do
            if [[ $DRY_RUN -eq 1 ]]; then
                dry_run_info "Would remove old archive: $(basename "$archive")"
            else
                info "Removing old archive: $(basename "$archive")"
                rm "$archive"
            fi
        done <<< "$archives_to_remove"
    fi
}

# Main rotation logic
rotate_logs() {
    local logs_to_rotate
    logs_to_rotate=$(get_logs_to_rotate)
    
    if [[ -z "$logs_to_rotate" ]]; then
        info "No logs older than $DAYS_THRESHOLD days found"
        return 0
    fi
    
    ensure_archive_dir
    
    while IFS= read -r log_file; do
        local log_name=$(basename "$log_file" .log)
        
        # Archive the log
        archive_log "$log_file"
        
        # Clean up old archives for this log type
        cleanup_old_archives "$log_name"
        
    done <<< "$logs_to_rotate"
}

# Generate summary
show_summary() {
    local total_logs
    local total_archives
    local archive_size
    
    total_logs=$(find "$LOGS_DIR" -maxdepth 1 -name "*.log" -type f | wc -l | tr -d ' ')
    
    if [[ -d "$ARCHIVE_DIR" ]]; then
        total_archives=$(find "$ARCHIVE_DIR" -name "*.log.gz" -type f | wc -l | tr -d ' ')
        archive_size=$(du -sh "$ARCHIVE_DIR" 2>/dev/null | cut -f1 | tr -d ' ')
    else
        total_archives=0
        archive_size="0B"
    fi
    
    info "Log rotation summary:"
    info "  Active logs: $total_logs"
    info "  Archived logs: $total_archives"
    info "  Archive size: $archive_size"
    info "  Retention: Keep $KEEP_ARCHIVES most recent archives per log type"
}

# Main execution
main() {
    parse_args "$@"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        warn "DRY RUN MODE - No changes will be made"
    fi
    
    info "Starting log rotation (threshold: ${DAYS_THRESHOLD} days, keep: ${KEEP_ARCHIVES} archives)"
    
    check_logs_dir
    rotate_logs
    show_summary
    
    if [[ $DRY_RUN -eq 1 ]]; then
        warn "DRY RUN COMPLETE - Run without --dry-run to apply changes"
    else
        success "Log rotation completed successfully"
    fi
}

# Execute main function with all arguments
main "$@"