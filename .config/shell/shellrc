#!/usr/bin/env bash
################################################################################
# This file is sourced only for login shells. It is used to define the bare
# minimum shell functions and env vars that are needed during bootstrap of a
# vanilla OS to bootstrap installation of all other config files.
#
# file location: ${HOME}/.shellrc
# load order: .zshenv [.shellrc], .zshrc [.shellrc, .aliases [.shellrc]], .zlogin
################################################################################

export LANG='en_US.UTF-8'
# Setting LC_ALL overrides all other LC_* variables.
# LANG is kept as a fallback.
export LC_ALL='en_US.UTF-8'
export LESSCHARSET='utf-8'

export ZDOTDIR="${ZDOTDIR:-${HOME}}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-${HOME}/.local/state}"

# Cache the architecture check to avoid calling `uname` repeatedly
[[ -z "${ARCH}" ]] && export ARCH="$(uname -m)"
export ARCHFLAGS="-arch ${ARCH}"

# =============================================================================
# Env vars for basic/common setup
# =============================================================================
export GIT_CONFIG_GLOBAL="${XDG_CONFIG_HOME}/git/config"

# The github username where the setup scripts are downloaded from
export GH_USERNAME='mahdz'

# This repo is cloned into this location
export DOTFILES="${HOME}/.dotfiles"

# Branch name of the dotfiles repo that's to be used for testing PR changes before merging
export DOTFILES_BRANCH='main'

# VS Code Workspace
export DOTFILES_WORKSPACE="${XDG_CONFIG_HOME:-$HOME/.config}/vscode/dotfiles.code-workspace"

# All development codebases are cloned into a subfolder of this folder
export PROJECTS_BASE_DIR="${HOME}/Developer"

# Executable scripts that are not shared as part of this public repo are present here
export PERSONAL_BIN_DIR="${HOME}/.local/bin"

# SSH Agent
export SSH_AUTH_SOCK="$HOME/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh"

# Obsidian Vault Path
export VAULT_PATH="$HOME/Vault"

# =============================================================================
# Dev Tool Variables
# =============================================================================

# Mise configuration
export MISE_NODE_COREPACK=0

# uv generally respects XDG variables for its cache and data directories.
# However, you can explicitly guide it for maximum control.
export UV_PYTHON_DOWNLOADS=auto
export UV_MANAGED_PYTHON=1

# uv cache directory (should default to XDG_CACHE_HOME/uv)
export UV_CACHE_DIR="${XDG_CACHE_HOME}/uv"

# uv Python installations directory (should default to XDG_DATA_HOME/uv/python)
export UV_PYTHON_INSTALL_DIR="${XDG_DATA_HOME}/uv/python" # Explicitly set if default is not desired

# uv tool installations directory (should default to XDG_DATA_HOME/uv/tools)
export UV_TOOL_DIR="${XDG_DATA_HOME}/uv/tools" # Explicitly set if default is not desired

# uv tool binary directory (should default to XDG_DATA_HOME/bin or XDG_BIN_HOME)
# uv usually places executables in XDG_DATA_HOME/bin, which we've added to PATH.
# If you want to explicitly set it:
export UV_TOOL_BIN_DIR="${XDG_BIN_HOME:-$HOME/.local/bin}"

# Python specific variables for uv (mostly handled by uv itself)
# PYTHONDONTWRITEBYTECODE: Prevents Python from writing .pyc files to source directories
export PYTHONDONTWRITEBYTECODE=1

# PYTHONSTARTUP: Path to a Python startup script (e.g., for common imports)
# If you have one, place it in an XDG-compliant location.
# export PYTHONSTARTUP="${XDG_CONFIG_HOME}/python/pythonrc.py"

# =============================================================================
# SECRETS CONFIGURATION
# =============================================================================

export PW_KEYCHAIN=~/Library/Keychains/Secrets.keychain-db
export PW_RC=${XDG_CONFIG_HOME}/pw/config

# =============================================================================
# PAGER CONFIGURATION
# =============================================================================
# Optimized less pager settings for terminal use

# -i: Ignore case for searches.
# -R: Handle "raw" control characters for colorized text.
# -X: Don't clear screen on exit.
# -S: Chop long lines, don't wrap.
# --mouse: Enable mouse wheel scrolling.
# --incsearch: Incremental searches.
# -x4: Sets tab stops to 4 spaces.
# --status-column: Show status column.
LESS_FLAGS="-i -R -X --incsearch --use-color --mouse --quit-if-one-screen -x4 --status-column --wheel-lines=3"
export LESS="$LESS_FLAGS"
# Some tools expect LESSFLAGS instead; exporting both is harmless
export LESSFLAGS="$LESS_FLAGS"
# export LESSHISTFILE="-"  # Disable less history file for privacy

# =============================================================================
# COLOR DEFINITIONS
# =============================================================================

colorize() {
  printf "\x1b[${1}m"
}

NC=$(colorize '0') # No Color
BLACK=$(colorize '0;30')
DARK_GRAY=$(colorize '1;30')
RED=$(colorize '0;31')
LIGHT_RED=$(colorize '1;31')
GREEN=$(colorize '0;32')
LIGHT_GREEN=$(colorize '1;32')
ORANGE=$(colorize '0;33')
YELLOW=$(colorize '1;33')
BLUE=$(colorize '0;34')
LIGHT_BLUE=$(colorize '1;34')
PURPLE=$(colorize '0;35')
LIGHT_PURPLE=$(colorize '1;35')
CYAN=$(colorize '0;36')
LIGHT_CYAN=$(colorize '1;36')
LIGHT_GRAY=$(colorize '0;37')
WHITE=$(colorize '1;37')

blue() {
  printf "${BLUE}${1}${NC}"
}

light_blue() {
  printf "${LIGHT_BLUE}${1}${NC}"
}

purple() {
  printf "${PURPLE}${1}${NC}"
}

light_purple() {
  printf "${LIGHT_PURPLE}${1}${NC}"
}

cyan() {
  printf "${CYAN}${1}${NC}"
}

light_cyan() {
  printf "${LIGHT_CYAN}${1}${NC}"
}

green() {
  printf "${GREEN}${1}${NC}"
}

light_green() {
  printf "${LIGHT_GREEN}${1}${NC}"
}

red() {
  printf "${RED}${1}${NC}"
}

light_red() {
  printf "${LIGHT_RED}${1}${NC}"
}

yellow() {
  printf "${YELLOW}${1}${NC}"
}

success() {
  echo "$(green '**SUCCESS**') ${1}"
}

warn() {
  echo "$(light_red '**WARN**') ${1}"
}

info() {
  printf "%b\\n" "${BOLD}${GREEN}[INFO]${NORMAL} $*"
}

debug() {
  echo "$(light_purple '**DEBUG**') ${1}"
}

error() {
  echo "$(red '**ERROR**') ${1}"
  exit 1
}

section_header() {
  echo "$(red '---------------------')"
  echo "$(blue '==>') $(purple "${1}")"
}

is_non_zero_string() {
  [[ -n "${1}" ]]
}

strip_trailing_slash() {
  echo "${1%\/}"
}

extract_last_segment() {
  local without_trailing_slash
  without_trailing_slash="$(strip_trailing_slash "${1}")"
  echo "${without_trailing_slash##*/}"
  unset without_trailing_slash
}

is_arm() {
  [[ "${ARCH}" =~ 'arm' ]]
}

is_file() {
  is_non_zero_string "${1}" && [[ -f "${1}" ]]
}

is_executable() {
  is_non_zero_string "${1}" && [[ -x "${1}" ]]
}

is_directory() {
  is_non_zero_string "${1}" && [[ -d "${1}" ]]
}

dir_has_children() {
  is_directory "${1}" && is_non_zero_string "$(ls -A "${1}")"
}

ensure_dir_exists() {
  if is_non_zero_string "${1}"; then
    mkdir -pv "${1}"
  else
    warn "Skipping creation of the directory since '$(yellow "${1}")' is not defined"
  fi
}

is_git_repo() {
  is_non_zero_string "${1}" && is_directory "${1}/.git"
}

load_file_if_exists() {
  # shellcheck disable=SC2015
  # shellcheck disable=SC1090
  is_file "${1}" && source "${1}"
}

# delete_directory_if_exists() {
#   is_directory "${1}" && echo "$(red 'Deleting') '$(green "${1}")'" && sudo rm -rf "${1}"
# }

command_exists() {
  type "${1}" &> /dev/null 2>&1
}

is_zsh() { [[ -n $ZSH_VERSION ]]; }

if is_zsh; then
  # to reload Zsh configuration files.
  # WARNING: Sourcing .zshenv/.zshrc/.zlogin from a file that might be sourced *by* them
  # can lead to infinite loops or unexpected behavior if not called carefully.
  # This is likely intended for manual use or specific bootstrap scenarios after config changes.
  # Note: This is kind of equivalent to 'omz reload', but that doesn't seem to work when installing on a vanilla OS
  load_zsh_configs() {
    local file_list=('.zshenv' '.zshrc')
    for file in "${file_list[@]}"; do
      load_file_if_exists "${ZDOTDIR}/${file}"
    done
    unset file
    unset file_list
  }
fi

append_to_path_if_dir_exists() {
  is_directory "${1}" && path+=("${1}")
}

append_to_fpath_if_dir_exists() {
  is_directory "${1}" && fpath+="${1}"
}

prepend_to_path_if_dir_exists() {
  is_directory "${1}" && export PATH="${1}:${PATH+:${PATH}}"
}

prepend_to_manpath_if_dir_exists() {
  is_directory "${1}" && export MANPATH="${1}:${MANPATH+:${MANPATH}}"
}

prepend_to_ldflags_if_dir_exists() {
  is_directory "${1}" && export LDFLAGS="-L${1} ${LDFLAGS+ ${LDFLAGS}}"
}

prepend_to_cppflags_if_dir_exists() {
  is_directory "${1}" && export CPPFLAGS="-I${1} ${CPPFLAGS+ ${CPPFLAGS}}"
}

prepend_to_pkg_config_path_if_dir_exists() {
  is_directory "${1}" && export PKG_CONFIG_PATH="${1}${PKG_CONFIG_PATH+:${PKG_CONFIG_PATH}}"
}

is_macos() {
  [[ "${OSTYPE}" =~ 'darwin' ]]
}

is-not-warpterm() {
  [[ $TERM_PROGRAM != WarpTerminal ]]
}
is-theme-starship() {
  [[ $ZSH_THEME == starship* ]]
}

# =============================================================================
# Ask for the administrator password upfront and keep it alive until this script has finished #
# =============================================================================
keep_sudo_alive() {
  section_header 'Keeping sudo alive till this script has finished'
  sudo -v
  while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &
}

folder_size() {
  local folder="${1:-$(pwd)}"
  echo "$(yellow "$(realpath "${folder}")") --> $(cyan "$(/usr/bin/du -sh "${folder}" | cut -f1)") bytes"
}

clone_repo_into() {
  local target_folder="${2}"
  ensure_dir_exists "${target_folder}"
  if ! is_git_repo "${target_folder}"; then
    local tmp_folder
    tmp_folder="$(mktemp -d)"
    # Note: Do not use --depth while cloning since that messes up when using upstream to rebase from
    git -C "${tmp_folder}" clone -q "${1}" .
    mv "${tmp_folder}/.git" "${target_folder}"
    git -C "${target_folder}" checkout .
    git -C "${target_folder}" submodule update --init --recursive --remote --rebase --force
    rm -rf "${tmp_folder}"
    success "Successfully cloned '$(yellow "${1}")$(green "' into '")$(yellow "${target_folder}")$(green "'")"

    local target_branch="${3}"
    if is_non_zero_string "${target_branch}"; then
      git -C "${target_folder}" switch "${target_branch}"
      local checked_out_branch
      checked_out_branch="$(git -C "${target_folder}" branch --show-current)"
      [[ "${checked_out_branch}" != "${target_branch}" ]] && error "'${target_branch}' is not equal to the branch that was checked out: '${checked_out_branch}'; something is wrong. Please correct before retrying!"
      unset checked_out_branch
    fi
    unset tmp_folder
    unset target_branch
  else
    warn "Skipping cloning of '$(yellow "${1}")' since '$(yellow "${target_folder}")' is already a git repo"
  fi
  unset target_folder
}

# =============================================================================
# Setup ssh scripts/directories
# =============================================================================

set_ssh_folder_permissions() {
  section_header 'Setting ssh config file permissions'
  local target_folder="${HOME}/.ssh"
  ensure_dir_exists "${target_folder}"
  # Set directory permissions first
  chmod 700 "${target_folder}"
  if dir_has_children "${target_folder}"; then
    find "${target_folder}" -type f -exec chmod 600 {} \;
    success "Ensured correct permissions for '$(yellow "${target_folder}")' and files within it."
  else
    warn "'$(yellow "${target_folder}")' exists but is empty. No file permissions to set."
  fi
  unset target_folder
}

# Moving homebrew env vars here itself so that the initial homebrew installation on a vanilla OS can be done/applied into memory immediately
if is_arm; then
  export HOMEBREW_PREFIX='/opt/homebrew'
else
  export HOMEBREW_PREFIX='/usr/local'
fi
export HOMEBREW_NO_ANALYTICS=1
export HOMEBREW_CLEANUP_MAX_AGE_DAYS=3
export HOMEBREW_CLEANUP_PERIODIC_FULL_DAYS=3
export HOMEBREW_VERBOSE_USING_DOTS=1
export HOMEBREW_BUNDLE_FILE="${XDG_CONFIG_HOME}/homebrew/Brewfile"
export HOMEBREW_BREWFILE="${XDG_CONFIG_HOME}/homebrew/Brewfile"

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

confirm() {
  local prompt="${1:-Are you sure?} [y/N] "
  # -n 1 = read one character only
  # -r = raw input (no backslash escapes)
  # -p = display prompt
  read -p "$prompt" -n 1 -r reply
  echo   # new line after keypress

  case "$reply" in
    y|Y) return 0 ;;   # success (yes)
    *)   echo "Cancelled."; return 1 ;;
  esac
}

section() {
  printf "\\n%b\\n" "${BOLD}${BLUE}=== $* ===${NORMAL}"
}

subsection() {
  printf "\\n%b\\n" "${BLUE}--- $* ---${NORMAL}"
}

have() {
  if [ -z "$1" ]; then
    echo "Usage: have <command, alias or function>"
    return 1 # false
  fi

  # Check if a command, alias or with the provided name exists
  if type "$1" &>/dev/null; then
    return 0 # true
  else
    return 1 # false
  fi
}

validate_not_empty() {
  local value="$1"
  local field_name="${2:-Input}"

  if [[ -z "$value" ]]; then
    error "$field_name cannot be empty"
    return 1
  fi
  return 0
}

validate_directory() {
  local path="$1"
  local description="${2:-Directory}"

  if [[ ! -d "$path" ]]; then
    error "$description does not exist: $path"
    return 1
  fi
  return 0
}

validate_file() {
  local path="$1"
  local description="${2:-File}"

  if [[ ! -f "$path" ]]; then
    error "$description does not exist: $path"
    return 1
  fi
  return 0
}

validate_writable() {
  local path="$1"
  local description="${2:-Path}"

  if [[ ! -w "$path" ]]; then
    error "$description is not writable: $path"
    return 1
  fi
  return 0
}

validate_not_root() {
  if [[ "$(id -u)" -eq 0 ]]; then
    error "This script should not be run as root. Please run as a regular user."
    return 1
  fi
  return 0
}
