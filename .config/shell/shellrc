#!/usr/bin/env zsh

# Cache the architecture check to avoid calling `uname` repeatedly
[[ -z "${ARCH}" ]] && export ARCH="$(uname -m)"
export ARCHFLAGS="-arch ${ARCH}"

# =============================================================================
# Env vars for basic/common setup
# =============================================================================

# The github username where the setup scripts are downloaded from
export GH_USERNAME='mahdz'

# All development codebases are cloned into a subfolder of this folder
export PROJECTS_BASE_DIR="${HOME}/Developer"

# Executable scripts that are not shared as part of this public repo are present here
export PERSONAL_BIN_DIR="${HOME}/.local/bin"

export SECRETS_DIR="${XDG_DATA_HOME}/secrets" # Never commit
export PW_RC="${XDG_CONFIG_HOME}/pw/config"
export PW_KEYCHAIN="${HOME}/Library/Keychains/${PW_KEYCHAIN_NAME:-Secrets}.keychain-db"

# =============================================================================
# COLOR DEFINITIONS
# =============================================================================

colorize() {
  printf "\x1b[${1}m"
}

# Faster than calling colorize() 15 times
NC=$'\e[0m'
BOLD=$'\e[1m'
BLACK=$'\e[0;30m'
RED=$'\e[0;31m'
GREEN=$'\e[0;32m'
YELLOW=$'\e[0;33m'
BLUE=$'\e[0;34m'
PURPLE=$'\e[0;35m'
CYAN=$'\e[0;36m'
WHITE=$'\e[0;37m'
NORMAL=$(colorize '0')    # Reset to normal (same as NC)
DARK_GRAY=$(colorize '1;30')
LIGHT_RED=$(colorize '1;31')
LIGHT_GREEN=$(colorize '1;32')
ORANGE=$(colorize '0;33')
LIGHT_BLUE=$(colorize '1;34')
LIGHT_PURPLE=$(colorize '1;35')
LIGHT_CYAN=$(colorize '1;36')
LIGHT_GRAY=$(colorize '0;37')

blue() {
  printf "${BLUE}${1}${NC}"
}

light_blue() {
  printf "${LIGHT_BLUE}${1}${NC}"
}

purple() {
  printf "${PURPLE}${1}${NC}"
}

light_purple() {
  printf "${LIGHT_PURPLE}${1}${NC}"
}

cyan() {
  printf "${CYAN}${1}${NC}"
}

light_cyan() {
  printf "${LIGHT_CYAN}${1}${NC}"
}

green() {
  printf "${GREEN}${1}${NC}"
}

light_green() {
  printf "${LIGHT_GREEN}${1}${NC}"
}

red() {
  printf "${RED}${1}${NC}"
}

light_red() {
  printf "${LIGHT_RED}${1}${NC}"
}

yellow() {
  printf "${YELLOW}${1}${NC}"
}

success() {
  echo "$(green '**SUCCESS**') ${1}"
}

warn() {
  echo "$(light_red '**WARN**') ${1}"
}

info() {
  printf "%b\\n" "${BOLD}${GREEN}[INFO]${NORMAL} $*"
}

debug() {
  echo "$(light_purple '**DEBUG**') ${1}"
}

error() {
  echo "$(red '**ERROR**') ${1}"
  exit 1
}

section_header() {
  echo "$(red '---------------------')"
  echo "$(blue '==>') $(purple "${1}")"
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

confirm() {
  local prompt="${1:-Are you sure?} [y/N] "
  # -n 1 = read one character only
  # -r = raw input (no backslash escapes)
  # -p = display prompt
  read -p "$prompt" -n 1 -r reply
  echo   # new line after keypress

  case "$reply" in
    y|Y) return 0 ;;   # success (yes)
    *)   echo "Cancelled."; return 1 ;;
  esac
}

section() {
  printf "\\n%b\\n" "${BOLD}${BLUE}=== $* ===${NORMAL}"
}

subsection() {
  printf "\\n%b\\n" "${BLUE}--- $* ---${NORMAL}"
}

have() {
  if [ -z "$1" ]; then
    echo "Usage: have <command, alias or function>"
    return 1 # false
  fi

  # Check if a command, alias or with the provided name exists
  if type "$1" &>/dev/null; then
    return 0 # true
  else
    return 1 # false
  fi
}

validate_not_empty() {
  local value="$1"
  local field_name="${2:-Input}"

  if [[ -z "$value" ]]; then
    error "$field_name cannot be empty"
    return 1
  fi
  return 0
}

validate_directory() {
  local path="$1"
  local description="${2:-Directory}"

  if [[ ! -d "$path" ]]; then
    error "$description does not exist: $path"
    return 1
  fi
  return 0
}

validate_file() {
  local path="$1"
  local description="${2:-File}"

  if [[ ! -f "$path" ]]; then
    error "$description does not exist: $path"
    return 1
  fi
  return 0
}

validate_writable() {
  local path="$1"
  local description="${2:-Path}"

  if [[ ! -w "$path" ]]; then
    error "$description is not writable: $path"
    return 1
  fi
  return 0
}

validate_not_root() {
  if [[ "$(id -u)" -eq 0 ]]; then
    error "This script should not be run as root. Please run as a regular user."
    return 1
  fi
  return 0
}

is_non_zero_string() {
  [[ -n "${1}" ]]
}

strip_trailing_slash() {
  echo "${1%\/}"
}

extract_last_segment() {
  local without_trailing_slash
  without_trailing_slash="$(strip_trailing_slash "${1}")"
  echo "${without_trailing_slash##*/}"
  unset without_trailing_slash
}

is_arm() {
  [[ "${ARCH}" =~ 'arm' ]]
}

is_file() {
  is_non_zero_string "${1}" && [[ -f "${1}" ]]
}

is_executable() {
  is_non_zero_string "${1}" && [[ -x "${1}" ]]
}

is_directory() {
  is_non_zero_string "${1}" && [[ -d "${1}" ]]
}

dir_has_children() {
  is_directory "${1}" && is_non_zero_string "$(ls -A "${1}")"
}

ensure_dir_exists() {
  if is_non_zero_string "${1}"; then
    mkdir -pv "${1}"
  else
    warn "Skipping creation of the directory since '$(yellow "${1}")' is not defined"
  fi
}

is_git_repo() {
  is_non_zero_string "${1}" && is_directory "${1}/.git"
}

load_file_if_exists() {
  # shellcheck disable=SC2015
  # shellcheck disable=SC1090
  is_file "${1}" && source "${1}"
}

# delete_directory_if_exists() {
#   is_directory "${1}" && echo "$(red 'Deleting') '$(green "${1}")'" && sudo rm -rf "${1}"
# }

command_exists() {
  type "${1}" &> /dev/null 2>&1
}

is_zsh() { [[ -n $ZSH_VERSION ]]; }

if is_zsh; then
  # ⚠️ WARNING: Re-sourcing startup files is risky!
  # Only use this after manual edits to config files.
  # Safer alternative: Start a new shell session.
  load_zsh_configs() {
    local file_list=('.zshenv' '.zshrc')
    for file in "${file_list[@]}"; do
      load_file_if_exists "${ZDOTDIR}/${file}"
    done
    unset file
    unset file_list
  }
fi

append_to_path_if_dir_exists() {
  is_directory "${1}" && path+=("$1")
}

prepend_to_path_if_dir_exists() {
  is_directory "${1}" && path=("$1" $path)
}

append_to_fpath_if_dir_exists() {
  is_directory "${1}" && fpath+="${1}"
}

prepend_to_manpath_if_dir_exists() {
  is_directory "${1}" && export MANPATH="${1}:${MANPATH+:${MANPATH}}"
}

prepend_to_ldflags_if_dir_exists() {
  is_directory "${1}" && export LDFLAGS="-L${1} ${LDFLAGS+ ${LDFLAGS}}"
}

prepend_to_cppflags_if_dir_exists() {
  is_directory "${1}" && export CPPFLAGS="-I${1} ${CPPFLAGS+ ${CPPFLAGS}}"
}

prepend_to_pkg_config_path_if_dir_exists() {
  is_directory "${1}" && export PKG_CONFIG_PATH="${1}${PKG_CONFIG_PATH+:${PKG_CONFIG_PATH}}"
}

is_macos() {
  [[ "${OSTYPE}" =~ 'darwin' ]]
}

# =============================================================================
# Ask for the administrator password upfront and keep it alive until this script has finished #
# =============================================================================
keep_sudo_alive() {
  section_header 'Keeping sudo alive till this script has finished'
  sudo -v
  while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &
}

folder_size() {
  local folder="${1:-$(pwd)}"
  echo "$(yellow "$(realpath "${folder}")") --> $(cyan "$(/usr/bin/du -sh "${folder}" | cut -f1)") bytes"
}

# =============================================================================
# Setup ssh scripts/directories
# =============================================================================

set_ssh_folder_permissions() {
  section_header 'Setting ssh config file permissions'
  local target_folder="${HOME}/.ssh"
  ensure_dir_exists "${target_folder}"
  # Set directory permissions first
  chmod 700 "${target_folder}"
  if dir_has_children "${target_folder}"; then
    find "${target_folder}" -type f -exec chmod 600 {} \;
    success "Ensured correct permissions for '$(yellow "${target_folder}")' and files within it."
  else
    warn "'$(yellow "${target_folder}")' exists but is empty. No file permissions to set."
  fi
  unset target_folder
}

# SSH Agent
if is_macos; then
  export SSH_AUTH_SOCK="${HOME}/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh"
fi
